# OpenAPI generated server

Spring Boot Server

## Overview
This server was generated by the [OpenAPI Generator](https://openapi-generator.tech) project.
By using the [OpenAPI-Spec](https://openapis.org), you can easily generate a server stub.
This is an example of building a OpenAPI-enabled server in Java using the SpringBoot framework.

The underlying library integrating OpenAPI to Spring Boot is [springdoc](https://springdoc.org). Springdoc will generate an OpenAPI v3 specification based on the generated Controller and Model classes. The specification is available to download using the following url:
http://localhost:8080/v3/api-docs/

Start your server as a simple java application: 

<code>mvn spring-boot:run</code>

if you'd like to have more debug output
<code>mvn spring-boot:run -Dspring-boot.run.arguments=--debug</code>

# Building and using profiling service

## Building the jar files
<code>mvn clean install -Plocal</code> builds the jar file for a local/worspace start
<code>mvn clean install -pdocker</code> builds the jar file for a docker based deployment of the server

Attention:
that the build works (mvn clean install) works, JooQ already needs access to the postgres database having the schema loaded in there. 

Without the availability of the postgres db and the schema loaded there, the build fails due to JooQ issues. 

So you might want to start the postgres service from the docker-compose.yml file. You may do that either in Visual Studio Code easily by pressing the button or on the command line using

<code>docker-compose up -d postgres</code>



## Building the docker image
<code>docker build -t profiling-service:latest .</code>

## Running docker compose to start
docker compose here consists out of three images. 

* one image for postgres
* one image for pgadmin, to administer postgres
* one image including the actics profiling service

<code>
# Run Docker Compose
docker-compose down
docker-compose build
docker-compose up -d
</code>

### Local vs. docker based configuration

The JDBC URL for the JooQ configuration is depending if a local or docker based execution should be done. In a local based execution, the localhost is ok. It's not for docker based execution, there the service name of postgres must be used. 

Additionally, within docker, the internal ports HAVE TO BE USED, so postgres runs on the 5432 standard port. 

That's why you may find two respective configurations: 

<code>src/main/resources/database-local.properties</code> including the settings for a workspace local execution

<code>src/main/resources/database-docker.properties</code> including the settings for a docker based execution. 

Due to the fact, that the server port settings are environment dependent aswell, 
it is actually possible to run the docker version of the profiling service at the same 
time with the local version of the profiling service. 

# Swagger / API
You can view the api documentation in swagger-ui by pointing to
http://localhost:8080/swagger-ui.html


# Reload/Regenerate DB Schema using postgres and JooQ
If you have to recreate the dB schema in postgres, for example as a foundation for the jooq generator, you may load the schema file to postgres directly using 

<code>psql -h localhost -U postgres -d profiling_db -f src/main/resources/schema.sql</code>

Where the 
* -U is the userId
* -d is the databaseName
* -f is the source of your DB Schema
* -h is obviously the host/IP

# Registering the DB Server at PGAdmin
If you would like to use PGAdmin (visual UI to manage the database), this is provided in the docker-compose.yml file for you. But after the login, you need to register the postgres database server within PGAdmin. 
Use the following properties to do that

* host: use the value host.docker.internal 
* port: obviously 5433
* user: postgres 
* password: per default password, except you've changed it